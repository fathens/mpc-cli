use crate::hash::hash_sha512_256i;
use crate::paillier::PublicKey;
use crate::utils::bytes::{from_biguint, to_biguint};
use crate::utils::{ecdsa, NTildei};
use crate::CryptoError;
use crate::Result;
use bytes::Bytes;
use common::mod_int::ModInt;
use common::random::{get_random_positive_int, get_random_positive_relatively_prime_int};
use elliptic_curve::sec1::{ModulusSize, ToEncodedPoint};
use elliptic_curve::{CurveArithmetic, FieldBytesSize};
use num_bigint::{BigUint, ToBigInt};
use num_integer::Integer;
use std::ops::Neg;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RangeProofAlice {
    z: BigUint,
    u: BigUint,
    w: BigUint,
    s: BigUint,
    s1: BigUint,
    s2: BigUint,
}

impl RangeProofAlice {
    pub fn new<C>(
        pk: &PublicKey,
        c: &BigUint,
        ntildei: &NTildei,
        m: &BigUint,
        r: &BigUint,
    ) -> Result<Self>
    where
        C: CurveArithmetic,
        C::AffinePoint: ToEncodedPoint<C>,
        FieldBytesSize<C>: ModulusSize,
    {
        let h1 = &ntildei.v1;
        let h2 = &ntildei.v2;

        let q = &ecdsa::curve_n::<C>();
        let q3 = &q.pow(3);
        let q_ntilde = &(q * &ntildei.n);
        let q3_ntilde = &(q3 * &ntildei.n);

        // 1.
        let alpha = &get_random_positive_int(q3).map_err(CryptoError::from)?;
        // 2.
        let beta = &get_random_positive_relatively_prime_int(pk.n()).map_err(CryptoError::from)?;

        // 3.
        let gamma = &get_random_positive_int(q3_ntilde).map_err(CryptoError::from)?;

        // 4.
        let rho = &get_random_positive_int(q_ntilde).map_err(CryptoError::from)?;

        // 5.
        let mod_ntilde = ModInt::new(&ntildei.n);
        let z = mod_ntilde.mul(&mod_ntilde.pow(h1, m), &mod_ntilde.pow(h2, rho));

        // 6.
        let mod_n_square = ModInt::new(&pk.n().pow(2));
        let u = mod_n_square.mul(
            &mod_n_square.pow(&(pk.n() + 1_u8), alpha),
            &mod_n_square.pow(beta, pk.n()),
        );

        // 7.
        let w = mod_ntilde.mul(&mod_ntilde.pow(h1, alpha), &mod_ntilde.pow(h2, gamma));

        // 8-9. e'
        let e = &{
            let ints = [pk.n(), &(pk.n() + 1_u8), c, &z, &u, &w];
            let hash = hash_sha512_256i(&ints);
            hash.rejection_sample(q)
        };

        let mod_n = ModInt::new(pk.n());
        let s = mod_n.mul(&mod_n.pow(r, e), beta);

        let s1 = e * m + alpha;
        let s2 = e * rho + gamma;

        Ok(Self { z, u, w, s, s1, s2 })
    }

    pub fn verify<C>(&self, pk: &PublicKey, ntildei: &NTildei, c: &BigUint) -> bool
    where
        C: CurveArithmetic,
        C::AffinePoint: ToEncodedPoint<C>,
        FieldBytesSize<C>: ModulusSize,
    {
        let q = &ecdsa::curve_n::<C>();
        let q3 = &q.pow(3);
        let n2 = pk.n().pow(2);

        if ntildei.n <= self.z {
            return false;
        }
        if n2 <= self.u {
            return false;
        }
        if ntildei.n <= self.w {
            return false;
        }
        if pk.n() <= &self.s {
            return false;
        }
        if self.z.gcd(&ntildei.n).bits() > 1 {
            return false;
        }
        if self.u.gcd(&n2).bits() > 1 {
            return false;
        }
        if self.w.gcd(&ntildei.n).bits() > 1 {
            return false;
        }
        if &self.s1 < q {
            return false;
        }
        if &self.s2 < q {
            return false;
        }

        // 3.
        if &self.s1 > q3 {
            return false;
        }

        let gamma = &(pk.n() + 1_u8);

        // 1-2. e'
        let e = &{
            let ints = [pk.n(), gamma, c, &self.z, &self.u, &self.w];
            let hash = hash_sha512_256i(&ints);
            hash.rejection_sample(q)
        };
        let minus_e = e.to_bigint().unwrap().neg();

        // 4.
        {
            let mod_n_square = ModInt::new(&n2);
            if let Ok(ce) = mod_n_square.powi(c, &minus_e) {
                let gs = mod_n_square.mul(
                    &mod_n_square.pow(gamma, &self.s1),
                    &mod_n_square.pow(&self.s, pk.n()),
                );
                if self.u != mod_n_square.mul(&gs, &ce) {
                    return false;
                }
            } else {
                return false;
            }
        }

        // 5.
        {
            let mod_ntilde = ModInt::new(&ntildei.n);
            if let Ok(ze) = mod_ntilde.powi(&self.z, &minus_e) {
                let hs = mod_ntilde.mul(
                    &mod_ntilde.pow(&ntildei.v1, &self.s1),
                    &mod_ntilde.pow(&ntildei.v2, &self.s2),
                );
                if self.w != mod_ntilde.mul(&hs, &ze) {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }

    const NUM_PARTS: usize = 6;
}

impl From<RangeProofAlice> for [Bytes; RangeProofAlice::NUM_PARTS] {
    fn from(src: RangeProofAlice) -> Self {
        [
            from_biguint(&src.z),
            from_biguint(&src.u),
            from_biguint(&src.w),
            from_biguint(&src.s),
            from_biguint(&src.s1),
            from_biguint(&src.s2),
        ]
    }
}

impl TryFrom<[Bytes; RangeProofAlice::NUM_PARTS]> for RangeProofAlice {
    type Error = CryptoError;
    fn try_from(src: [Bytes; RangeProofAlice::NUM_PARTS]) -> Result<Self> {
        Ok(Self {
            z: to_biguint(&src[0])?,
            u: to_biguint(&src[1])?,
            w: to_biguint(&src[2])?,
            s: to_biguint(&src[3])?,
            s1: to_biguint(&src[4])?,
            s2: to_biguint(&src[5])?,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::paillier::PrivateKey;
    use k256::Secp256k1;
    use std::str::FromStr;

    struct Param {
        pk: PublicKey,
        ntildei: NTildei,
        c: BigUint,
        m: BigUint,
        r: BigUint,
    }

    type C = Secp256k1;

    fn gen_param(ken_len: u64) -> Param {
        let q = ecdsa::curve_n::<C>();
        let sk = PrivateKey::generate(ken_len);
        let pk = sk.public_key().to_owned();
        let ntildei = NTildei::generate_for_test()[0].clone();

        let m = get_random_positive_int(&q).unwrap();
        let en = pk.encrypt(&m).unwrap();
        let c = en.cypher;
        let r = en.randomness;
        Param {
            pk,
            c,
            ntildei,
            m,
            r,
        }
    }

    fn sample() -> (Param, RangeProofAlice) {
        let biguint = |s| BigUint::from_str(s).unwrap();
        let param = Param {
            pk: PublicKey::new(biguint("24318637407772017247415107554516370151573397806432151675958701926900677445475691056558545868977169121128554233008847556530769112547469655283464674311030104874166077471786177109883720855511764379370107126854706659607866439422091197098901420259607868981467514783834424519939073247199909676024997097468708687411469374692772584635370093227707363538949831041705877511014689633831325568523436840586498779671225934212708104654297372436096976828507065131569477062834711811481867079812418667866417290649346258233704270282401280159251067309250659223955953688203240857614988107027418835899457997686226300513563567962645061609761")),
            c: biguint("28164464486444225183845179841984875332811367976666144743522547348079153317841579639413312789166938736331692501435051412420380575230601234790373134024219974059826662744210023723638245656665409015208179773299099324399357998677786501640284813949090155185495570923291336809812882034006383448549663877485042424721147840541554535897611225615774222315929316470219635228746220796945150008345217494057883810929658112029304682330653973067151258166071214734712683779582152944396269964074555685902204585963363701982657712961152712789647384995713639896897069715455187056237017953433575290257741727103651334539267749145241386386946253875376485025089879596387421006005196327448526551837886390491079779914204689214152685400992523506813937983971240227405777044814637183342638916622164463662220189571061509284886070106746840965925964109527359841329322312220036085055300016127213564051478578346751575912930881902015621049015530378931971237456773332287997421400253799748980049934138784188274440893819535503002890527838608304062808798547996709753442717630215569063840111055911702582245235335816069621846105931846108462889441943132924602278963777603464651070938554867349322338649876175764482884345095980958602343930965304679827662000114895414373273803251"),
            ntildei: NTildei {
                n: biguint("21160461107636610138762246369265161923753852526883432758025680016968282276616857956454351610548245078046822162969103098800657192596383941557926844324089285013330454698489638175444026088693137646259686615819457804486051154051657090872632113619239942858124810991612555803142796595594550976928532786999999603508885640108225155756692058093265030121861318244344960980149612323009432701208832408785170280402130831736376617966623851594740238319957501715351930351881497978292852353916962977649472050239801050631293055256463657695335146542218541656544145737288631265455219338211350592484071450047416980584060741593166181707689"),
                v1: biguint("19927603225246509518211654134903620042528996366965901053105966225500544702610896230427089400868580795037001311497194201076706092210605869593916403421122975434745908779478662121021597217385815302797518413214937259230991101400945560381544474175965376329233191975495714169655664359985538365143298165156312711216790132633031533674901535407434886698133494804274122244104355137630447138641381609696618737090705072827157069000660403605661162707038654574279033612098788354251907178451084681404054828365302234634532900678489839349457745271603397862911076271459769236327839838160814726368167618358956530659673040622360203153993"),
                v2: biguint("12281191982864331864662833299333578830330803041222659256838383947651549550192898662618500437464515557340662631321846162202133319640377152875139764652731498899732427318108034614939207153176334495302594597221763478485593447447665434036151900571030148841515408350010412720827346788810993952933513690144179350325572286832257196330206850779488490633532153956671846056286507465639908513395240817509008696474006359211739507494304691739195689267548674967194543780123950049787670667662957149088395982618528950378752586267978534390972744631985146992366928416859377180795003596148477012402449331717821690298570775710782900323389"),
            },
            m: biguint("44450694278711070471355097836934008014134810198639235434834286646984780295699"),
            r: biguint("18715356384546740617337724366955259573628115598285417922033940564086783942334888533173791589201846266930385312003528983299099152751480693844161202306406672612852242476222622849482118580510003866521234249159637091239231178007032679152112840125225697233066599028374545961094950502267843288399890553235023072101379557195435706960415401859889329707225125962332938839894409436775322202833770908013635222015373827007444811676069792019185265706734251796565131729721554605991976462413795929356018017041062314441097410505376756806947028038970126504016968433638089778599588065774926213976642755889168103672659049433040567608938"),
        };

        let rp = RangeProofAlice {
            z: biguint("1065568989795665615496287768818898068609273720196864968019540574931602104024195923302436032864886726390018306418063874754331396501712646860304448435218207278176790699435865892282439019684779173858843649345675584704852455853938014470376813869971747851996157444061938564362669209029274782003551066780129398157431652788525751700076633975420134126993960864630267118636844209078031045386466744284093823423208625894879868541779350984005029034079598112117999099553981899725538003376715921880554490653635989983320098472700073264789163636265635854816141177513602548431107176858036079206291792573570712727886609054334470611558"),
            u: biguint("324963132764431263295792333374043277525158856433052003719509029463821951408919163133883565079075771715853725816079982370330089351776289770311196607107353059817131549035060942314729035590840285940320065381303414440206113928100093962906254244880220931747177937857816532100540402603672565963924680271825269737013956196065775709957582364343519715726248681370920756867248077555679861613635949322458318166121941582870517611253855200085227805214673627000024234977808862093347362675214401803003667789748837185044122867707323219552963688701734517112434323616232972445713208781306460704421452805524062902600572870681430323957353384370304363536369693162703274244462000446273839609832406888155050536102611166583262505172074284651888048546593680872400946954713668582973177933763031927205141834471117230332058571741973161738538917631281360353691002786864578662210053588379287547874884030548027466386391373796428383333131322489453665890747417508774936695698004583665701715838119220115819898260089325203176135466532366459649330504798311093672825524077769643528988074117230725357989461000815914532354516908262880136240797168781130398453730342824069060413336234634155801579470420951858374890453721733477914576686258499510121195912903378641644421438453"),
            w: biguint("12593047072336766194924580788114660024039078606108764647834383850382340502746523165171479801920322214170638193486879619738371442775442437182689036114681465832888055932607433359829084173109713967297826549394880909724043687053467618178007301191851421074222500071975316640030962024002883045241525641839600059735772522279528183851781515953292057421259252877703811900320728850619349510650625933693415059373146783399595862680188548287019946071573528963835629403808143632443937769428368303089228229616077657222215356276427442942810295399373161228673673640859888662924125185458439522954486224319249504242579134478124440363986"),
            s: biguint("18991917585475005889864106163916257353771204980827508655643370271762288421318300159673258914725605420425709921008172064607690674534741906580552765352427676283196849002573230826129186563030485696450884508264935784352000577654753707049312008631253177886963452955428419278506839496428719797499303356008337107075472512391537848581585608949151103913296490369709905886977516764832159706060424438165566581338238392623162017309892228430828317974178286614823580465496342428390050959962340233932016540338507471390920308055884808815352365156371897945910285272829384687229327507135594498903471369892234903055547311689859614340023"),
            s1: biguint("80798448801825677862187318181532356264056061889444766335111268165331320726209400271348659613544666530827604308252416806033998303976940718370235262565604066678538620344519923244347739573908548253876877448078627360283992078311647051"),
            s2: biguint("27540132255712560570547419968033682606544710650124807050293812083001291895332977986952323372498107676623559223408960361133812615314378796675312003074391709134716174910312744406338343556052832815817603571634182486462920706350911337686576957610903007689635030128254077352501049040293089929647335004563126195036137418382899970718841323870509638671401065486664554822073968215113865750370176259180409416949835456430622414284871984881075940062229349349899064788968604968538223178209550444462750020835765468154792625197731748967576413722262456481166188238316668134669207277062859074093702633972244023769661861548147819701760806111654390716925137131644374945297154904783175717892148271674351916117488620740102204734971979384443218050178985776478821941265598432481113677203406083764896572578963842373941033536287332922710209560128573499713890950931493110294"),
        };

        (param, rp)
    }

    fn loop_new_and_verify(n: u8, param: &Param) {
        for _ in 0..n {
            let res =
                RangeProofAlice::new::<C>(&param.pk, &param.c, &param.ntildei, &param.m, &param.r);
            assert!(res.is_ok());
            let rp = res.unwrap();
            assert!(rp.verify::<C>(&param.pk, &param.ntildei, &param.c));
        }
    }

    #[test]
    fn verify_by_gen() {
        let param = gen_param(1024);
        loop_new_and_verify(10, &param);
    }

    #[test]
    fn verify_by_sample() {
        let (param, rp) = sample();
        assert!(rp.verify::<C>(&param.pk, &param.ntildei, &param.c));
    }

    #[test]
    fn test_from_into() {
        let (_, src) = sample();
        let bs: [Bytes; RangeProofAlice::NUM_PARTS] = src.clone().into();
        let dst: RangeProofAlice = bs.try_into().unwrap();
        assert_eq!(src, dst);
    }
}
